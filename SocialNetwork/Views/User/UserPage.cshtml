@using SocialNetwork.DLL.Entities
@model SocialNetwork.Models.ViewModels.Account.UserViewModel

@{
    Layout = "_UserLayout";
}

@{
    ViewData["Title"] = $"{ViewBag.targetUser?.GetFullName() ?? "Неизвестный пользователь"} page";
}

@{
    string userId = string.IsNullOrEmpty(ViewBag.targetUser?.Id) ? Model._user.Id : ViewBag.targetUser.Id;
}

<h2>Лента @ViewBag.targetUser?.GetFullName() </h2>

<div id="messageSection"></div>
<div id="loading" style="display: none; text-align: center">
    Загрузка...
</div>


@* 
<script>
    document.addEventListener('DOMContentLoaded',
        () => {
            let currentPage = 1;
            let hasMore = true;
            let loading = false;
            const pageSize = 10;


            // Создаем триггер для загрузки
            const loadTrigger = document.createElement('div');
            loadTrigger.id = 'load-trigger';
            loadTrigger.style.height = '1px';
            loadTrigger.style.visibility = 'hidden';
            document.getElementById('messageSection').appendChild(loadTrigger);

            // Наблюдатель за триггером
            const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && hasMore && !loading) {
                            loadMessages();
                        }
                    });
                },
                { threshold: 0.1 });

            observer.observe(loadTrigger);

            async function loadMessages() {
                loading = true;

                try {
                    const response = await fetch(`/AccountManager/load-messages?UserID=@userId&page=${currentPage}`);
                    const result = await response.json();

                    if (result.data && result.data.length > 0) {
                        // Добавляем сообщения
                        const messageSection = document.getElementById('messageSection');
                        result.data.forEach(message => {
                            const messageHtml = `
                           <div class="card" data-message-id="${message.messageId}">
            <div class="card-body">
                <div class="card-subtitle">
                    <h6 class="card-subtitle-author">${message.authorFullName}</h6>
                    <h6 class="card-subtitle-date">${new Date(message.createdAt).toLocaleString()}</h6>
                    ${message.deletable ? '<span><img src="@Url.Content("~/images/trashbox.svg")"></span>' : ''}
                    </div>
                <p class="card-text">${message.text}</p>
                <div class="comment-section">
    ${message.comments.map(comment => `
        <div class="card-comment" data-comment-id="${comment.commentId}">
            <div class="card-subtitle">
                <h6 class="card-subtitle-author">${comment.author}</h6>
                <h6 class="card-subtitle-date">${new Date(comment.createdAt).toLocaleString()}</h6>
                ${comment.deletable ? '<span><img src="@Url.Content("~/images/trashbox.svg")"></span>' : ''}
            </div>
            <p class="card-text">${comment.text}</p>
        </div>
    `).join('')}

                </div>
                <button class="btn-primary addComment">Добавить комментарий</button>
            </div>
        </div>`;

                            messageSection.insertAdjacentHTML('beforeend', messageHtml);
                        });

                        // Обновляем флаг и страницу
                        hasMore = result.hasMore;
                        currentPage++;

                        // Перемещаем триггер в конец
                        messageSection.appendChild(loadTrigger);
                    } else {
                        hasMore = false;
                        loadTrigger.remove();
                    }

                } catch (error) {
                    console.error('Ошибка загрузки:', error);
                } finally {
                    loading = false;
                }
            }

            // Первоначальная загрузка
            loadMessages();
        });

</script>
                        
<script>
      // Обработчик комментариев
        document.addEventListener('click',
            async function(e) {
                // Добавление поля для комментария
                if (e.target.classList.contains('addComment')) {
                    const commentInput = `
                    <textarea class="form-control comment-area" rows="2" placeholder="Введите комментарий..."></textarea>
                    <button class="btn-primary submitComment">Отправить</button>`;
                    const commentSection = e.target.previousElementSibling;
                    commentSection.insertAdjacentHTML('beforeend', commentInput);
                    e.target.remove();
                }

                // Отправка комментария
                if (e.target.classList.contains('submitComment')) {
                    const textarea = e.target.previousElementSibling;
                    const text = textarea.value.trim();
                    const messageId = e.target.closest('.card').dataset.messageId;

                    if (!text) return;

                    try {
                            const response = await fetch('/AccountManager/add-comment',
                            {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                                },
                                body: JSON.stringify({
                                    MessageId: parseInt(messageId),
                                    Text: text
                                })
                            });

                        const commentData = await response.json();

                        // Тело комментария
                        const commentHtml = `
                        <div class="card-comment">
                            <div class="card-subtitle">
                                <h6 class="card-subtitle-author">${commentData.author}</h6>
                                <h6 class="card-subtitle-date">${commentData.timestamp}</h6>
                           <span><img src="@Url.Content("~/images/trashbox.svg")"></span>
                            </div>
                            <p class="card-text">${commentData.text}</p>
                        </div>`;


                        const commentSection = e.target.parentElement;
                        const commentButton = '<button class="btn-primary addComment">Добавить комментарий</button>';
                        // Добавляем комментарий
                        commentSection.insertAdjacentHTML('beforeend', commentHtml);
                        // Добавляем кнопку
                        commentSection.insertAdjacentHTML('afterend', commentButton);

                        // Удаляем поле ввода
                        textarea.remove();
                        e.target.remove();

                    } catch (error) {
                        console.error('Ошибка:', error);
                    }
                }
            });
</script>

                        
<script>
    document.addEventListener('DOMContentLoaded',
        function() {
            // Функция для настройки textarea
            function processTextarea(textarea) {
                // Если обработчик уже прикреплён, пропускаем
                if (!textarea.hasAttribute('data-autosize-attached')) {
                    textarea.addEventListener('input',
                        function() {
                            textarea.style.height = 'auto';
                            textarea.style.height = textarea.scrollHeight + 'px';
                        });
                    textarea.setAttribute('data-autosize-attached', 'true');
                }
                // Первоначальная настройка высоты
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            }

            // Инициализируем уже существующие textarea
            document.querySelectorAll('textarea.form-control').forEach(processTextarea);

            // Создаём наблюдатель за изменениями в документе
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    mutation.addedNodes.forEach(function(node) {
                        // Если добавлен узел является элементом
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            // Если сам узел является textarea с нужным классом
                            if (node.matches && node.matches('textarea.form-control')) {
                                processTextarea(node);
                            }
                            // Если внутри добавленного узла есть дочерние textarea
                            if (node.querySelectorAll) {
                                node.querySelectorAll('textarea.form-control').forEach(processTextarea);
                            }
                        }
                    });
                });
            });

            // Настраиваем наблюдение за всем документом
            observer.observe(document.body, { childList: true, subtree: true });
        });


</script> *@